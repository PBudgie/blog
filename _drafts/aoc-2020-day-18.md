---
layout: post
title:  "Advent of Code 2020 Day 18 Solution"
---

[AoC 2020 Day 18](https://adventofcode.com/2020/day/18) involves parsing mathematical expressions. My final solution used the Shunting Yard algorithm that I adapted for tree expressions. I thought it'd be fun to represent expressions as binary trees and use recursion to evaluate them.

**Expressions as Trees**

The following diagrams show how expressions look as binary trees.

Each of the circles in the diagram above is a node. Each node is connected to a left and right node. Once we have all our nodes connected to each other, we can grab the entire tree by just having our topmost "root" node. This is the standard binary tree representation in JavaScript.

```javascript
class Node {
    constructor(token) {
        this.token = token
        this.left = null
        this.right = null
    }

    setLeft(node) {
        this.left = node
    }

    setRight(node) {
        this.right = node
    }
}
```

To evaluate a given expression tree, here is our cute little recursive function.

```javascript
function evaluateTree(node) {
    if(node.token != "*" && node.token != "+") {
        return parseInt(node.token)
    } else if(node.token == "*") {
        return evaluateTree(node.left) * evaluateTree(node.right)
    } else if(node.token == "+") {
        return evaluateTree(node.left) + evaluateTree(node.right)
    }
}
```

Great, we have our tree structure down. But how do we actually convert an expression into a tree?

**Using the Shunting Yard Algorithm**

Compilers use the Shunting Yard algorithm to parse expressions. Take a look at the [Shunting Yard pseudocode here](https://brilliant.org/wiki/shunting-yard-algorithm/). Let's convert that pseudocode into what we'll use for this problem.

Check out [my final code solution]() with all the bells and whistles.

**My Faulty First Attempt**

I used [this website](http://www.openbookproject.net/books/pythonds/Trees/ParseTree.html) for my first attempt at the problem. Let's convert the algorithm detailed there into this problem space: Given an expression, traverse the expression from left to right. When we encounter a token, we follow these rules.

1. If the current token is a `(`, add a new node as the left child of the current node, and descend to that left child.
2. If the current token is `+` or `*`, set the value of the current node to the token. Add a new node as the right child of the current node and descend to the right child.
3. If the current token is a number, set the root value of the current node to the number and return to the parent.
4. If the current token is a `)`, go to the parent of the current node.

However, there was a big problem with the algorithm detailed above. It's difficult to see since the example seemed to work so well! What happens when we try to use the algorithm to convert `8 + (1 * 2 * 3)` into a tree?

This problem happens because when we encounter an open parenthesis, we don't know how many terms are inside the parenthesis. So when we try to create left nodes following rule 1, we don't know how many left nodes to create. And we can't simply look ahead and find the corresponding closing parenthesis because it's possible to have nested parentheses, as in `8 + (1 * (1 + 3 + 6))`. The Shunting Yard algorithm avoids this problem by 